# v0.4.0: azure_ai_foundry_tools Crate

## Overview

This plan implements the `azure_ai_foundry_tools` crate, which wraps two Azure AI Services accessible through AI Foundry:

1. **Vision** - Image Analysis 4.0 (GA, API version `2024-02-01`), providing synchronous visual analysis via `POST /computervision/imageanalysis:analyze`. Supports seven visual features: `tags`, `caption`, `denseCaptions`, `objects`, `read`, `smartCrops`, `people`.

2. **Document Intelligence** - Document Intelligence v4.0 (GA, API version `2024-11-30`), providing asynchronous document analysis via `POST /documentintelligence/documentModels/{modelId}:analyze`. Uses a polling pattern: submit returns `202 Accepted` with `Operation-Location` header; client polls `GET /documentintelligence/documentModels/{modelId}/analyzeResults/{resultId}` until `status == "succeeded"`.

**Architecture decisions already made:**
- Same `FoundryClient` from `azure_ai_foundry_core` is reused (no new HTTP client).
- Both APIs use different base paths, so no conflict on the same endpoint.
- Document Intelligence is asynchronous (long-running operation); Vision is synchronous.
- The `post()` / `get()` / `delete()` methods on `FoundryClient` are already available.
- A new `get_raw()` method may be needed to fetch the full URL returned in `Operation-Location` (not a relative path).

**Stack detected**: Rust 1.88, Tokio async, reqwest HTTP client, serde/serde_json, thiserror, tracing, wiremock for tests.

**Conventions observed in existing crates:**
- One file per domain module (`vision.rs`, `document_intelligence.rs`).
- Shared types in `models.rs`.
- `lib.rs` exposes all modules and a `test_utils` module gated by `#[cfg(test)]`.
- Builder pattern for all request types with validation in `build()`.
- `FoundryResult<T>` as return type for all public functions.
- `#[tracing::instrument]` on every public async function.
- `#[serde(skip_serializing_if = "Option::is_none")]` for optional fields.
- Tests co-located in `#[cfg(test)] mod tests` inside each source file.
- `wiremock` with `MockServer` for HTTP-level tests.
- Constants for `API_VERSION` in a `models.rs`.
- Tracing span names follow pattern `foundry::<service>::<operation>`.

---

## Phase 1: Crate Scaffold

### Cycle 1: Workspace registration and Cargo.toml

- RED: There are no tests to write here — compilation itself is the test. The crate must compile cleanly with `cargo check --workspace --all-targets`.
- GREEN: Create `sdk/azure_ai_foundry_tools/Cargo.toml` with the following content, following the pattern of `azure_ai_foundry_agents/Cargo.toml`:
  - File: `/Volumes/WD_BLACK/repos/MojoBytes/azure-ai-foundry/sdk/azure_ai_foundry_tools/Cargo.toml`
  - Declare `azure_ai_foundry_core` as dependency (path + version = "0.3.0" — or match the workspace version at time of implementation).
  - Include `serde`, `serde_json`, `reqwest`, `tokio`, `tracing` from workspace.
  - Dev-dependencies: `tokio` with full+test-util features, `wiremock`, `tracing-test = "0.2"`.
  - Feature `integration-tests = []`.
  - Uncomment the `sdk/azure_ai_foundry_tools` line in the root `Cargo.toml` workspace members.
- REFACTOR: Verify `cargo check --workspace` produces zero errors and zero warnings after scaffold.

### Cycle 2: Minimal lib.rs compiles

- RED: `cargo check --workspace --all-targets` fails because `sdk/azure_ai_foundry_tools/src/lib.rs` does not exist.
- GREEN: Create `sdk/azure_ai_foundry_tools/src/lib.rs` with:
  - File: `/Volumes/WD_BLACK/repos/MojoBytes/azure-ai-foundry/sdk/azure_ai_foundry_tools/src/lib.rs`
  - Crate-level doc comment describing the crate purpose (Vision + Document Intelligence).
  - Empty module declarations: `pub mod models;`, `pub mod vision;`, `pub mod document_intelligence;`.
  - `test_utils` module (identical pattern to agents crate): `setup_mock_client()`, `TEST_API_KEY`, `TEST_TIMESTAMP`.
  - Create stub files `src/models.rs`, `src/vision.rs`, `src/document_intelligence.rs` with only a module-level doc comment to satisfy `mod` declarations.
- REFACTOR: Run `cargo clippy --workspace --all-targets -- -D warnings`. All must pass.

---

## Phase 2: Shared Models

### Cycle 3: API version constants

- RED: Write test `test_vision_api_version_format` in `src/models.rs`:
  - Assert: `VISION_API_VERSION` contains `"2024-02-01"`.
  - Assert: `DOCUMENT_INTELLIGENCE_API_VERSION` contains `"2024-11-30"`.
  - Test is in `#[cfg(test)] mod tests` inside `src/models.rs`.
- GREEN: Define in `src/models.rs`:
  ```
  pub(crate) const VISION_API_VERSION: &str = "api-version=2024-02-01";
  pub(crate) const DOCUMENT_INTELLIGENCE_API_VERSION: &str = "api-version=2024-11-30";
  ```
- REFACTOR: Add a brief module doc comment explaining these are the API versions for each service.

### Cycle 4: BoundingBox type

- RED: Write test `test_bounding_box_deserialization` in `src/models.rs`:
  - Input JSON: `{"x": 10, "y": 20, "w": 100, "h": 50}`
  - Assert: `bounding_box.x == 10`, `bounding_box.y == 20`, `bounding_box.w == 100`, `bounding_box.h == 50`.
- GREEN: Define `BoundingBox` struct in `src/models.rs`:
  - Fields: `x: i32`, `y: i32`, `w: i32`, `h: i32`.
  - Derive: `Debug, Clone, Deserialize`.
  - Public visibility, with doc comments on each field.
- REFACTOR: None needed.

### Cycle 5: ImageMetadata type

- RED: Write test `test_image_metadata_deserialization` in `src/models.rs`:
  - Input JSON: `{"width": 1920, "height": 1080}`
  - Assert: `metadata.width == 1920`, `metadata.height == 1080`.
- GREEN: Define `ImageMetadata` struct:
  - Fields: `width: u32`, `height: u32`.
  - Derive: `Debug, Clone, Deserialize`.
- REFACTOR: None needed.

---

## Phase 3: Vision Module - Types

### Cycle 6: VisualFeature enum serialization

- RED: Write tests in `src/vision.rs` `#[cfg(test)] mod tests`:
  - `test_visual_feature_serialization`: verify each variant serializes to the correct lowercase string.
    - `VisualFeature::Tags` -> `"tags"`.
    - `VisualFeature::Caption` -> `"caption"`.
    - `VisualFeature::DenseCaptions` -> `"denseCaptions"`.
    - `VisualFeature::Objects` -> `"objects"`.
    - `VisualFeature::Read` -> `"read"`.
    - `VisualFeature::SmartCrops` -> `"smartCrops"`.
    - `VisualFeature::People` -> `"people"`.
  - Uses `serde_json::to_string(&variant)`.
- GREEN: Define in `src/vision.rs`:
  ```rust
  #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  pub enum VisualFeature {
      #[serde(rename = "tags")] Tags,
      #[serde(rename = "caption")] Caption,
      #[serde(rename = "denseCaptions")] DenseCaptions,
      #[serde(rename = "objects")] Objects,
      #[serde(rename = "read")] Read,
      #[serde(rename = "smartCrops")] SmartCrops,
      #[serde(rename = "people")] People,
  }
  ```
  Note: `VisualFeature` is sent as comma-separated values in the URL query string, not in the body, so `Serialize` is for that conversion.
- REFACTOR: Add doc comment on enum and each variant describing what the feature detects.

### Cycle 7: ImageAnalysisRequest builder - required fields

- RED: Write test `test_image_analysis_request_requires_features` in `src/vision.rs`:
  - Assert: `ImageAnalysisRequest::builder().url("https://example.com/img.png").build()` returns `Err` with message containing `"features"`.
  - Write test `test_image_analysis_request_requires_url`:
    - Assert: builder with no URL returns `Err` with message containing `"url"`.
- GREEN: Define `ImageAnalysisRequest` and `ImageAnalysisRequestBuilder`:
  - `url: String` (required).
  - `features: Vec<VisualFeature>` (required, at least one).
  - `language: Option<String>` (optional).
  - `model_version: Option<String>` (optional).
  - `smartcrops_aspect_ratios: Option<Vec<f64>>` (optional, for SmartCrops feature).
  - `gender_neutral_caption: Option<bool>` (optional).
  - `build()` returns `FoundryResult<ImageAnalysisRequest>`.
  - Validation: URL must not be empty; features must not be empty.
- REFACTOR: None needed.

### Cycle 8: ImageAnalysisRequest builder - all fields and serialization

- RED: Write test `test_image_analysis_request_features_serialized` in `src/vision.rs`:
  - Build a request with URL `"https://example.com/img.png"` and features `[Tags, Caption]`.
  - Serialize to JSON: `serde_json::to_value(&request)`.
  - Assert: JSON body only contains `"url": "https://example.com/img.png"` (features go in query string, not body).
  - Write test `test_image_analysis_request_features_to_query_string`:
    - Call a helper method `request.features_query_param()` -> `String`.
    - Assert result is `"tags,caption"` for `[Tags, Caption]`.
- GREEN:
  - The request body JSON contains only `url`.
  - Add `features_query_param(&self) -> String` method that joins feature names with `,`.
  - Add builder methods: `url()`, `features()`, `language()`, `model_version()`, `smartcrops_aspect_ratios()`, `gender_neutral_caption()`.
- REFACTOR: Validate URL starts with `"https://"` or `"http://"`. Validate smartcrops aspect ratios are between 0.75 and 1.8 inclusive. Return `FoundryError::Builder` for each violation.

### Cycle 9: Vision response types deserialization

- RED: Write test `test_image_analysis_result_deserialization_minimal` in `src/vision.rs`:
  - Input: `{"modelVersion": "2024-02-01", "metadata": {"width": 800, "height": 600}}`.
  - Assert: `result.model_version == "2024-02-01"`, `result.metadata.width == 800`.
- Write test `test_image_analysis_result_deserialization_full`:
  - Include all optional fields: `captionResult`, `tagsResult`, `objectsResult`, `readResult`, `denseCaptionsResult`, `smartCropsResult`, `peopleResult`.
  - Assert presence and first-element values of each collection.
- GREEN: Define response types:
  - `ImageAnalysisResult` with fields:
    - `model_version: String` (serde rename `modelVersion`).
    - `metadata: ImageMetadata` (from models.rs).
    - `caption_result: Option<CaptionResult>` (serde rename `captionResult`).
    - `tags_result: Option<TagsResult>` (serde rename `tagsResult`).
    - `objects_result: Option<ObjectsResult>` (serde rename `objectsResult`).
    - `read_result: Option<ReadResult>` (serde rename `readResult`).
    - `dense_captions_result: Option<DenseCaptionsResult>` (serde rename `denseCaptionsResult`).
    - `smart_crops_result: Option<SmartCropsResult>` (serde rename `smartCropsResult`).
    - `people_result: Option<PeopleResult>` (serde rename `peopleResult`).
  - `CaptionResult { text: String, confidence: f64 }`.
  - `ContentTag { name: String, confidence: f64 }`.
  - `TagsResult { values: Vec<ContentTag> }`.
  - `DetectedObject { id: String, bounding_box: BoundingBox (rename "boundingBox"), tags: Vec<ContentTag> }`.
  - `ObjectsResult { values: Vec<DetectedObject> }`.
  - `ImagePoint { x: i32, y: i32 }`.
  - `DetectedTextWord { text: String, bounding_polygon: Vec<ImagePoint> (rename "boundingPolygon"), confidence: f64 }`.
  - `DetectedTextLine { text: String, bounding_polygon: Vec<ImagePoint> (rename "boundingPolygon"), words: Vec<DetectedTextWord> }`.
  - `DetectedTextBlock { lines: Vec<DetectedTextLine> }`.
  - `ReadResult { blocks: Vec<DetectedTextBlock> }`.
  - `DenseCaption { text: String, confidence: f64, bounding_box: BoundingBox (rename "boundingBox") }`.
  - `DenseCaptionsResult { values: Vec<DenseCaption> }`.
  - `CropRegion { aspect_ratio: f64 (rename "aspectRatio"), bounding_box: BoundingBox (rename "boundingBox") }`.
  - `SmartCropsResult { values: Vec<CropRegion> }`.
  - `DetectedPerson { bounding_box: BoundingBox (rename "boundingBox"), confidence: f64 }`.
  - `PeopleResult { values: Vec<DetectedPerson> }`.
  - All derive `Debug, Clone, Deserialize`.
- REFACTOR: Move `ImageMetadata`, `BoundingBox`, `ImagePoint` to `models.rs` if they are shared (they are not used by Document Intelligence, so keeping them in `vision.rs` is also valid — decision: keep them in `models.rs` for future extensibility since `BoundingBox` is a universal concept).

---

## Phase 4: Vision Module - API Function

### Cycle 10: `vision::analyze` success path

- RED: Write test `test_analyze_image_success` in `src/vision.rs`:
  - Start `MockServer`.
  - Register `Mock::given(method("POST")).and(path("/computervision/imageanalysis:analyze")).and(header("Authorization", "Bearer test-api-key")).respond_with(ResponseTemplate::new(200).set_body_json(...))`.
  - Call `vision::analyze(&client, &request).await`.
  - Assert: response `model_version` matches, `metadata.width` matches.
- GREEN: Implement `pub async fn analyze(client: &FoundryClient, request: &ImageAnalysisRequest) -> FoundryResult<ImageAnalysisResult>`:
  - Build query string: `format!("/computervision/imageanalysis:analyze?features={}&{}", request.features_query_param(), VISION_API_VERSION)`.
  - Append optional params: `language`, `model_version`, `gender_neutral_caption`, `smartcrops_aspect_ratios`.
  - The request body is `{"url": "<request.url>"}` (serialize only URL to body).
  - Call `client.post(&path, &body).await?` where body is `serde_json::json!({"url": request.url})`.
  - Deserialize response as `ImageAnalysisResult`.
  - Add `#[tracing::instrument(name = "foundry::vision::analyze", skip(client, request), fields(features = %request.features_query_param()))]`.
- REFACTOR: Add `tracing::debug!` calls at start and end.

### Cycle 11: `vision::analyze` error handling

- RED: Write test `test_analyze_image_api_error` in `src/vision.rs`:
  - Mock server returns `404` with body `{"error": {"code": "InvalidImageUrl", "message": "URL is not accessible"}}`.
  - Assert: result is `Err(FoundryError::Api { code, .. })` where `code == "InvalidImageUrl"`.
- Write test `test_analyze_image_http_error`:
  - Mock server returns `429` with plain text body.
  - Assert: result is `Err(FoundryError::Http { status: 429, .. })`.
- GREEN: Error handling is inherited from `FoundryClient::post()` which already handles error status codes via the existing error-checking logic in `client.rs`.
- REFACTOR: None needed — verify tests pass and error variants match expectations.

### Cycle 12: Vision tracing instrumentation

- RED: Write test `test_analyze_emits_vision_span` using `#[traced_test]` from `tracing-test`:
  - Call `vision::analyze(&client, &request).await` with successful mock.
  - Assert: `logs_contain("foundry::vision::analyze")`.
- GREEN: The `#[tracing::instrument]` attribute added in Cycle 10 already covers this.
- REFACTOR: None needed.

---

## Phase 5: Document Intelligence Module - Types

### Cycle 13: DocumentAnalysisRequest builder

- RED: Write test `test_doc_analysis_request_requires_model_id` in `src/document_intelligence.rs`:
  - Assert: builder with no `model_id` returns `Err` with message containing `"model_id"`.
- Write test `test_doc_analysis_request_requires_source`:
  - Assert: builder with `model_id` but no source (`url_source` nor `base64_source`) returns `Err` with message containing `"source"`.
- Write test `test_doc_analysis_request_rejects_both_sources`:
  - Assert: builder with both `url_source` and `base64_source` set returns `Err` with message containing `"only one"` or `"url_source or base64_source"`.
- GREEN: Define `DocumentAnalysisRequest` and `DocumentAnalysisRequestBuilder`:
  - Required: `model_id: String`.
  - Source (exactly one required): `url_source: Option<String>`, `base64_source: Option<String>`.
  - Optional: `pages: Option<String>` (pattern `"1-3,5"`), `locale: Option<String>`, `features: Option<Vec<DocumentAnalysisFeature>>`.
  - `build()` validates: model_id non-empty, exactly one of url_source/base64_source set.
- REFACTOR: Add `DocumentAnalysisFeature` enum in `src/document_intelligence.rs` with variants matching the API: `OcrHighResolution`, `Languages`, `Barcodes`, `Formulas`, `KeyValuePairs`, `StyleFont`, `QueryFields`. Each variant serializes with `serde(rename_all = "camelCase")` or explicit renames.

### Cycle 14: DocumentAnalysisRequest serialization

- RED: Write test `test_doc_analysis_request_url_source_serialization`:
  - Build request with `model_id = "prebuilt-read"`, `url_source = "http://host.com/doc.pdf"`.
  - Serialize to JSON: `serde_json::to_value(&request.body())` (the body is only `{urlSource: ...}` or `{base64Source: ...}`).
  - Assert: JSON has `"urlSource": "http://host.com/doc.pdf"`, does NOT have `"base64Source"`.
- Write test `test_doc_analysis_request_base64_source_serialization`:
  - Assert: JSON has `"base64Source": "..."`, does NOT have `"urlSource"`.
- GREEN: Define an inner `DocumentAnalysisBody` struct (the actual JSON body) with `url_source: Option<String>` (rename `urlSource`) and `base64_source: Option<String>` (rename `base64Source`), both with `skip_serializing_if = "Option::is_none"`. `DocumentAnalysisRequest::body()` returns this struct.
- REFACTOR: None needed.

### Cycle 15: AnalyzeResultStatus and AnalyzeOperationResult deserialization

- RED: Write test `test_analyze_operation_status_deserialization` in `src/document_intelligence.rs`:
  - `"notStarted"` -> `AnalyzeResultStatus::NotStarted`.
  - `"running"` -> `AnalyzeResultStatus::Running`.
  - `"succeeded"` -> `AnalyzeResultStatus::Succeeded`.
  - `"failed"` -> `AnalyzeResultStatus::Failed`.
- Write test `test_analyze_operation_result_deserialization_succeeded`:
  - Input JSON with `"status": "succeeded"`, `"analyzeResult": {"apiVersion": "2024-11-30", "modelId": "prebuilt-read", "content": "Hello world", "pages": [...]}`.
  - Assert: `result.status == AnalyzeResultStatus::Succeeded`, `result.analyze_result.is_some()`.
- Write test `test_analyze_operation_result_deserialization_running`:
  - Input JSON with `"status": "running"`, no `analyzeResult`.
  - Assert: `result.status == AnalyzeResultStatus::Running`, `result.analyze_result.is_none()`.
- GREEN: Define:
  - `AnalyzeResultStatus` enum: `NotStarted`, `Running`, `Succeeded`, `Failed`. Derive `Debug, Clone, Copy, PartialEq, Eq, Deserialize` with `serde(rename_all = "camelCase")`.
  - `AnalyzeOperationResult` struct: `status: AnalyzeResultStatus`, `analyze_result: Option<AnalyzeResult>` (rename `analyzeResult`).
  - `AnalyzeResult` struct: `api_version: String` (rename `apiVersion`), `model_id: String` (rename `modelId`), `content: Option<String>`, `pages: Option<Vec<DocumentPage>>`, `tables: Option<Vec<DocumentTable>>`, `key_value_pairs: Option<Vec<DocumentKeyValuePair>>` (rename `keyValuePairs`), `documents: Option<Vec<DocumentTypeResult>>`.
  - `DocumentPage` struct: `page_number: u32` (rename `pageNumber`), `angle: Option<f64>`, `width: Option<f64>`, `height: Option<f64>`, `unit: Option<String>`, `words: Option<Vec<DocumentWord>>`, `lines: Option<Vec<DocumentLine>>`.
  - `DocumentWord` struct: `content: String`, `confidence: f64`.
  - `DocumentLine` struct: `content: String`.
  - `DocumentTable` struct: `row_count: u32` (rename `rowCount`), `column_count: u32` (rename `columnCount`), `cells: Vec<DocumentTableCell>`.
  - `DocumentTableCell` struct: `row_index: u32` (rename `rowIndex`), `column_index: u32` (rename `columnIndex`), `content: String`.
  - `DocumentKeyValuePair` struct: `key: Option<DocumentKeyValueElement>`, `value: Option<DocumentKeyValueElement>`, `confidence: f64`.
  - `DocumentKeyValueElement` struct: `content: Option<String>`.
  - `DocumentTypeResult` struct: `doc_type: String` (rename `docType`), `fields: Option<serde_json::Value>`, `confidence: Option<f64>`.
  - All derive `Debug, Clone, Deserialize`.
- REFACTOR: `AnalyzeResultStatus::is_terminal(&self) -> bool` method returning `true` for `Succeeded` and `Failed`.

---

## Phase 6: Document Intelligence Module - API Functions

### Cycle 16: `document_intelligence::analyze` success path (submit)

- RED: Write test `test_analyze_document_submit_success` in `src/document_intelligence.rs`:
  - Mock server: `POST /documentintelligence/documentModels/prebuilt-read:analyze` returns `202` with header `Operation-Location: http://<server_uri>/documentintelligence/documentModels/prebuilt-read/analyzeResults/result-id-123`.
  - Call `document_intelligence::analyze(&client, &request).await`.
  - Assert: returned `operation_location` URL contains `"result-id-123"`.
- GREEN: Define `OperationStatus` struct: `operation_location: String`.
  Implement `pub async fn analyze(client: &FoundryClient, request: &DocumentAnalysisRequest) -> FoundryResult<OperationStatus>`:
  - Build path: `format!("/documentintelligence/documentModels/{}:analyze?{}", request.model_id, DOCUMENT_INTELLIGENCE_API_VERSION)`.
  - Append optional query params: `pages`, `locale`.
  - Append features as comma-separated: `features=ocrHighResolution,languages` etc.
  - Call `client.post(&path, &request.body()).await?`.
  - Extract `Operation-Location` header from response.
  - Return `OperationStatus { operation_location }`.
  - Add tracing: `#[tracing::instrument(name = "foundry::document_intelligence::analyze", skip(client, request), fields(model_id = %request.model_id))]`.
- REFACTOR: Validate the `202` status explicitly. If the status is not `202`, propagate as `FoundryError::Http`.

### Cycle 17: Extracting `Operation-Location` header

- RED: Write test `test_analyze_document_missing_operation_location` in `src/document_intelligence.rs`:
  - Mock server returns `202` but WITHOUT the `Operation-Location` header.
  - Assert: result is `Err(FoundryError::MissingConfig(_))` or `Err(FoundryError::Http {..})` with a message referencing `"Operation-Location"`.
- GREEN: In the `analyze` function, after getting the `202` response, attempt to read the `Operation-Location` header. If absent, return `FoundryError::MissingConfig("Operation-Location header missing from response".into())`.
- REFACTOR: None needed.

### Cycle 18: `document_intelligence::get_result` polling function

- RED: Write test `test_get_analyze_result_succeeded` in `src/document_intelligence.rs`:
  - Mock server: `GET /documentintelligence/documentModels/prebuilt-read/analyzeResults/result-id-123` returns `200` with body `{"status": "succeeded", "analyzeResult": {"apiVersion": "2024-11-30", "modelId": "prebuilt-read", "content": "Hello world"}}`.
  - Call `document_intelligence::get_result(&client, &operation_location).await`.
  - Assert: `result.status == AnalyzeResultStatus::Succeeded`, `result.analyze_result.is_some()`.
- GREEN: Implement `pub async fn get_result(client: &FoundryClient, operation_location: &str) -> FoundryResult<AnalyzeOperationResult>`:
  - The `operation_location` is a full URL (not a relative path). Extract the path from the URL: parse as `url::Url`, extract `path()` + `query()`.
  - Call `client.get(&relative_path).await?`.
  - Deserialize as `AnalyzeOperationResult`.
  - Add tracing: `#[tracing::instrument(name = "foundry::document_intelligence::get_result", skip(client), fields(operation_location = %operation_location))]`.
- REFACTOR: Consider whether `client.get()` accepts relative paths only. If the full URL is needed, a new method `client.get_url()` may need to be added to `FoundryClient` in `azure_ai_foundry_core`. If needed, add that method first (as a separate cycle — see Cycle 19).

### Cycle 19: FoundryClient::get_url method (if needed)

This cycle is conditional — only execute if the existing `client.get(&path)` only accepts relative paths and cannot handle the full `Operation-Location` URL.

- RED: Write test in `azure_ai_foundry_core/src/client.rs` or the tools crate's integration test, verifying that calling `client.get_url("http://mock-server/some/path")` makes a GET request to that full URL.
- GREEN: Add `pub async fn get_url(&self, url: &str) -> FoundryResult<reqwest::Response>` to `FoundryClient` in `sdk/azure_ai_foundry_core/src/client.rs`:
  - This method does NOT prepend the base endpoint — it uses `url` as-is.
  - Attach authorization headers as normal.
  - Return the response.
- REFACTOR: Ensure this method is documented with a warning that it bypasses the base endpoint; it is intended for polling long-running operation results.

### Cycle 20: `document_intelligence::poll_until_complete` function

- RED: Write test `test_poll_until_complete_immediate_success` in `src/document_intelligence.rs`:
  - Mock first GET: returns `{"status": "running"}`.
  - Mock second GET (same path): returns `{"status": "succeeded", "analyzeResult": {...}}`.
  - Call `document_intelligence::poll_until_complete(&client, &operation_location, Duration::from_millis(1)).await`.
  - Assert: final `result.status == AnalyzeResultStatus::Succeeded`.
- Write test `test_poll_until_complete_failed_status`:
  - Mock returns `{"status": "failed"}` immediately.
  - Assert: returns `Ok(result)` where `result.status == AnalyzeResultStatus::Failed` (not an error — the caller decides what to do with a failed result).
- GREEN: Implement `pub async fn poll_until_complete(client: &FoundryClient, operation_location: &str, poll_interval: std::time::Duration) -> FoundryResult<AnalyzeOperationResult>`:
  - Loop: call `get_result()`, check `status.is_terminal()`.
  - If terminal, return `Ok(result)`.
  - If not, `tokio::time::sleep(poll_interval).await` and repeat.
  - Add tracing: `#[tracing::instrument(name = "foundry::document_intelligence::poll_until_complete", skip(client))]`.
- REFACTOR: Add `tracing::trace!` inside the loop to log each polling attempt.

### Cycle 21: Prebuilt model ID constants

- RED: Write test `test_prebuilt_model_id_constants` in `src/document_intelligence.rs`:
  - Assert: `PREBUILT_READ == "prebuilt-read"`.
  - Assert: `PREBUILT_LAYOUT == "prebuilt-layout"`.
  - Assert: `PREBUILT_INVOICE == "prebuilt-invoice"`.
  - Assert: `PREBUILT_RECEIPT == "prebuilt-receipt"`.
  - Assert: `PREBUILT_ID_DOCUMENT == "prebuilt-idDocument"`.
  - Assert: `PREBUILT_BUSINESS_CARD == "prebuilt-businessCard"`.
- GREEN: Define public constants in `src/document_intelligence.rs`:
  ```rust
  pub const PREBUILT_READ: &str = "prebuilt-read";
  pub const PREBUILT_LAYOUT: &str = "prebuilt-layout";
  pub const PREBUILT_INVOICE: &str = "prebuilt-invoice";
  pub const PREBUILT_RECEIPT: &str = "prebuilt-receipt";
  pub const PREBUILT_ID_DOCUMENT: &str = "prebuilt-idDocument";
  pub const PREBUILT_BUSINESS_CARD: &str = "prebuilt-businessCard";
  ```
- REFACTOR: Doc comments on each constant explaining what data the model extracts.

---

## Phase 7: Document Intelligence Module - Error Handling

### Cycle 22: Non-202 response from analyze submit

- RED: Write test `test_analyze_document_unauthorized_error`:
  - Mock returns `401` with `{"error": {"code": "Unauthorized", "message": "Invalid API key"}}`.
  - Assert: result is `Err(FoundryError::Api { code, .. })` or `Err(FoundryError::Http { status: 401, .. })`.
- Write test `test_analyze_document_model_not_found_error`:
  - Mock returns `404` with API error body.
  - Assert: result is `Err`.
- GREEN: These pass automatically if `FoundryClient::post()` already handles non-success status codes (verify by reviewing `client.rs`). If not, explicit status checks are needed.
- REFACTOR: None needed.

### Cycle 23: Document Intelligence tracing

- RED: Write test `test_analyze_document_emits_span` using `#[traced_test]`:
  - Call `document_intelligence::analyze()` with successful mock.
  - Assert: `logs_contain("foundry::document_intelligence::analyze")`.
- Write test `test_poll_until_complete_emits_span`:
  - Assert: `logs_contain("foundry::document_intelligence::poll_until_complete")`.
- GREEN: Already covered by `#[tracing::instrument]` attributes from Cycles 16 and 20.
- REFACTOR: None needed.

---

## Phase 8: lib.rs - Public API and Documentation

### Cycle 24: Re-exports and crate-level documentation

- RED: Write test `test_crate_exports_accessible` (doc-test in `lib.rs`):
  ```rust
  //! ```rust,no_run
  //! use azure_ai_foundry_tools::vision::{self, ImageAnalysisRequest, VisualFeature};
  //! use azure_ai_foundry_tools::document_intelligence::{self, DocumentAnalysisRequest, PREBUILT_READ};
  //! ```
  This must compile — verified by `cargo test --doc`.
- GREEN: Update `src/lib.rs` with:
  - Comprehensive crate-level doc comment with Quick Start examples for both Vision and Document Intelligence.
  - `pub mod models;`, `pub mod vision;`, `pub mod document_intelligence;`.
- REFACTOR: Run `cargo doc --workspace --no-deps` and verify docs render correctly with no warnings.

---

## Phase 9: Workspace Cargo.toml and Integration

### Cycle 25: Workspace version and dependency declaration

- RED: `cargo build --workspace` must compile all four crates with no errors.
- GREEN:
  - In root `Cargo.toml`, uncomment `"sdk/azure_ai_foundry_tools"` in `[workspace.members]`.
  - Verify the workspace `version` field (currently `"0.2.0"`) is bumped to `"0.3.0"` in `[workspace.package]` if needed (coordinate with release process).
  - Verify `azure_ai_foundry_tools` does NOT depend on `azure_ai_foundry_models` or `azure_ai_foundry_agents` — it only depends on `azure_ai_foundry_core`.
- REFACTOR: Run the full CI command sequence:
  1. `cargo fmt --all -- --check`
  2. `cargo clippy --workspace --all-targets -- -D warnings`
  3. `cargo test --workspace`
  4. `cargo doc --workspace --no-deps`
  All must pass with zero warnings and zero errors.

### Cycle 26: README for azure_ai_foundry_tools

- Note: README is documentation, not code. It is NOT a markdown file created speculatively. Only create if the user explicitly requests it. Verify the crate's `Cargo.toml` points `documentation` to the correct docs.rs URL when published.

---

## Summary of Files to Create

| File | Action |
|------|--------|
| `/Volumes/WD_BLACK/repos/MojoBytes/azure-ai-foundry/sdk/azure_ai_foundry_tools/Cargo.toml` | Create |
| `/Volumes/WD_BLACK/repos/MojoBytes/azure-ai-foundry/sdk/azure_ai_foundry_tools/src/lib.rs` | Create |
| `/Volumes/WD_BLACK/repos/MojoBytes/azure-ai-foundry/sdk/azure_ai_foundry_tools/src/models.rs` | Create |
| `/Volumes/WD_BLACK/repos/MojoBytes/azure-ai-foundry/sdk/azure_ai_foundry_tools/src/vision.rs` | Create |
| `/Volumes/WD_BLACK/repos/MojoBytes/azure-ai-foundry/sdk/azure_ai_foundry_tools/src/document_intelligence.rs` | Create |
| `/Volumes/WD_BLACK/repos/MojoBytes/azure-ai-foundry/Cargo.toml` | Modify (uncomment tools crate) |
| `/Volumes/WD_BLACK/repos/MojoBytes/azure-ai-foundry/sdk/azure_ai_foundry_core/src/client.rs` | Modify (add `get_url()` if needed — Cycle 19) |

## Summary of TDD Cycles

| Cycle | Phase | Subject | Type |
|-------|-------|---------|------|
| 1 | Scaffold | Cargo.toml and workspace registration | Compilation |
| 2 | Scaffold | Minimal lib.rs compiles | Compilation |
| 3 | Models | API version constants | Unit |
| 4 | Models | BoundingBox deserialization | Unit |
| 5 | Models | ImageMetadata deserialization | Unit |
| 6 | Vision Types | VisualFeature enum serialization | Unit |
| 7 | Vision Types | ImageAnalysisRequest builder validation | Unit |
| 8 | Vision Types | Request body serialization and feature query string | Unit |
| 9 | Vision Types | ImageAnalysisResult full deserialization | Unit |
| 10 | Vision API | `analyze` success path via mock | Integration |
| 11 | Vision API | `analyze` error handling | Integration |
| 12 | Vision API | Tracing span emission | Integration |
| 13 | Doc Intel Types | DocumentAnalysisRequest builder validation | Unit |
| 14 | Doc Intel Types | Request body serialization | Unit |
| 15 | Doc Intel Types | AnalyzeResultStatus and AnalyzeOperationResult deserialization | Unit |
| 16 | Doc Intel API | `analyze` submit success (202 + Operation-Location) | Integration |
| 17 | Doc Intel API | Missing Operation-Location header error | Integration |
| 18 | Doc Intel API | `get_result` polling function | Integration |
| 19 | Core (conditional) | `FoundryClient::get_url` method | Unit/Integration |
| 20 | Doc Intel API | `poll_until_complete` function | Integration |
| 21 | Doc Intel API | Prebuilt model ID constants | Unit |
| 22 | Doc Intel Errors | Non-202 error propagation | Integration |
| 23 | Doc Intel API | Tracing span emission | Integration |
| 24 | lib.rs | Public API re-exports and doc-tests | Doc-test |
| 25 | Workspace | Full workspace compiles and all tests pass | Compilation/Integration |

## Tracing Spans for azure_ai_foundry_tools

| Span Name | Fields |
|-----------|--------|
| `foundry::vision::analyze` | `features` (comma-separated feature names) |
| `foundry::document_intelligence::analyze` | `model_id` |
| `foundry::document_intelligence::get_result` | `operation_location` |
| `foundry::document_intelligence::poll_until_complete` | `operation_location` |

## Estimated Effort

- Cycles 1-2 (Scaffold): 30 min
- Cycles 3-5 (Shared Models): 30 min
- Cycles 6-9 (Vision Types): 45 min
- Cycles 10-12 (Vision API): 30 min
- Cycles 13-15 (Doc Intel Types): 60 min
- Cycles 16-23 (Doc Intel API + Errors): 90 min
- Cycles 24-25 (Integration): 30 min
- **Total**: ~5.5 hours

## Criteria for Success

- [ ] `cargo test --workspace` passes all tests (target: ~320+ total, ~50 new in tools crate).
- [ ] `cargo clippy --workspace --all-targets -- -D warnings` emits zero warnings.
- [ ] `cargo fmt --all -- --check` passes.
- [ ] `cargo doc --workspace --no-deps` produces zero warnings.
- [ ] All public functions have doc comments with `# Example` sections using `no_run`.
- [ ] All public async functions have `#[tracing::instrument]` attributes.
- [ ] Tests use `wiremock` for HTTP-level verification, not just unit tests.
- [ ] No production code is written before a failing test exists for it.
